## 6.1 Software Configuration Management

A continuación, se presentará un repositorio central y organizado que servirá como guía para el desarrollo enfocado y consistente de nuestra solución.

### 6.1.1 Software Development Environment Configuration

En esta sección se incluye los links de las aplicaciones, productos de software realizadas durante el ciclo del proyecto en los programas que se utilizaron. <br>
Para ello se clasificará en las siguientes secciones:
*	Project Management
*	Requirements Management
*	Product UX/UI Design 
*	Software Development
*	Software Testing
*	Software Deployment
*	Software Documentation

<br>
Y clasificar los elementos de las secciones si es ruta de referencia (para software basado en modelos SaaS) o ruta de descarga (para productos que se ejecutan en el computador del miembro del equipo) de cada uno de los productos de software.<br><br>

<strong>Project Management</strong><br>
Es la disciplina basada en la gestión de los proyectos, la cual tiene como objetivo principal mejorar los procesos y su entorno para alcanzar los resultados esperados.

*	<strong>Pivotal Tracker:</strong> Herramienta ágil para gestionar proyectos de desarrollo de software de manera eficiente y colaborativa. Priorización automática, tablero interactivo y métricas clave. Ideal para equipos ágiles. <br>
https://www.pivotaltracker.com

<strong>Requirements Management</strong>
Es el proceso de garantizar que una organización documente verifique y satisfaga las necesidades, expectativas de sus clientes con las partes interesadas internas o externas.

*	<strong>Pivotal Tracker:</strong> Esta herramienta se define como una plataforma en la que se realiza la gestión de User Stories, agrupándoles en Epics y clasificando su presencia en el programa, por puntaje. Se usó porque permite que cada miembro del equipo comparte la misma vista en tiempo real de lo que está sucediendo con cada proyecto, ya sea aportando con diferentes secciones o corrigiendo el flujo del proyecto. <br>
https://www.pivotaltracker.com/n/projects/2675473

<strong>Product UX/UI Design </strong><br>
Esta herramienta permite desarrollar el modelo en nuestro producto de manera digital y forme parte de la vida del consumidor.  En este caso realizar un modelo de sitio web para computadoras y celulares.

* <strong>UXPressia:</strong><br> es una herramienta en línea para el mapeo de la trayectoria del cliente que crea mapas de impacto y personas. Sus herramientas nos permitieron establecer las bases del modelado de User Persona, Empathy Map y Journey Map.
https://uxpressia.com/ 

* <strong>MIRO:</strong><br>es una pizarra digital colaborativa en línea, que puede ser usada para la investigación, la ideación, la creación de lluvias de ideas, mapas mentales y una variedad de otras actividades colaborativas.
https://miro.com/app/dashboard/ 

* <strong>Figma:</strong><br>es una herramienta de prototipo web y editor de gráficos vectorial, que, a diferencia de las otras herramientas, se aloja en la web, permitiendo establecer los modelos para versión en Web Browser y Mobile Browser.
https://www.figma.com/design/ 

* <strong>Lucid Chart:</strong><br> es una herramienta de diagramación basada en la web, que permite a los usuarios colaborar y trabajar juntos en tiempo real, creando diseños UML, mapas mentales, prototipos de software y muchos otros tipos de diagrama.
https://lucid.app/documents#/dashboard 

* <strong>Structurizr:</strong><br> es una herramienta de diseño que soporta el modelo C4, para visualizar la arquitectura de software de nuestra solución. 
https://structurizr.com/ 

<strong>Software Development</strong><br>
Es una estructura aplicada al desarrollo de un producto de software. Se utiliza para el establecimiento de un proceso para el desarrollo de software, cada uno de los cuales describe un enfoque diferente para diferentes actividades que tienen lugar durante el proceso.

* <strong>GitHub:</strong><br> Es un repositorio comunitario cuya función es almacenar los avances de un proyecto elaborado por un grupo de personas. <br>
https://github.com/NexusNova-IOT

* <strong>WebStorm:</strong><br> Es un entorno de JetBrains, empresa desarrolladora de Software, orientado en el desarrollo web en JavaScript. Este nos ofrece facilidad en probar nuestro entorno web en navegadores como Google. Para el proyecto se implementará la ayuda de los lenguajes HTML, CSS y JavaScript.<br>
https://www.jetbrains.com/webstorm/

* <strong>Visual Studio Code:</strong><br> Es un editor potente que brinda extensiones que nos permiten personalizar y agregar funcionalidades para que la función del desarrollador sea más eficiente. Asimismo, se empleará para poder construir el backend de nuestro web Applications.<br>
https://code.visualstudio.com/ 

* <strong>HTML:</strong><br> Es un lenguaje que sirve como desarrollador de plataformas web que trabaja con hipertextos, que enlace a otros documentos. Este lenguaje ofrece herramientas para el diseño del sitio web. Asimismo, la disponibilidad de trabajar HTML junto con CSS y JavaScript. Este lenguaje será utilizado en el presente proyecto para implementar la documentación de la página web.<br>
https://www.jetbrains.com/help/webstorm/editing-html-files.html 

* <strong>CSS:</strong><br> Es un lenguaje de diseño para el entorno web. Permite elaborar el interfaz de usuario diseñada anteriormente, agregando colores, tamaños entre otros elementos. Además, se puede diseñar un estilo en CSS y compartirlo en el web elaborado en HTML. Este lenguaje se utilizará para la implementación del diseño de nuestra plataforma web.<br>
https://www.jetbrains.com/help/webstorm/style-sheets.html#ws_css_completion 

* <strong>JavaScript:</strong><br> Es un lenguaje de programación que es analizado por otros programas. Este trabaja en POO (programación orientada en objetos) para prototipos sin implementación con clases. Este programa permite realizar dinámicas para el usuario a través de la lógica de la programación. Se utilizará para la elaboración de las dinámicas de la plataforma web.<br>
https://www.jetbrains.com/help/webstorm/javascript-specific-guidelines.html 

* <strong>Java:</strong><br> Es un lenguaje de programación que es analizado por otros programas. Este es ampliamente utilizado para codificar aplicaciones web. Este programa permite realizar dinámicas para el usuario a través de la lógica de la programación. Se utilizará para la elaboración de las dinámicas de la plataforma web.<br>
https://www.java.com/es/download/ie_manual.jsp 

* <strong>TypeScript:</strong><br> Es un superset de JavaScript. Este lenguaje nos permite aplicar programas de javaScript, pero cabe resaltar que no funciona al revés. Su principal funcionalidad es que pone a disposición del desarrollador librerías y frameworks que existen para JavaScript.<br>
https://www.typescriptlang.org/ 

* <strong>Angular Material:</strong><br>Es modulo construido por Angular, para implementar componentes Angular con un diseño basado en Material Design.<br>
https://material.angular.io/ 

* <strong>C++:</strong><br>Lenguaje de programación utilizado para escribir código en placas Arduino. Facilita la programación de dispositivos y sistemas embebidos de forma efectiva y versátil.<br>
https://www.jetbrains.com/cpp/

* <strong>ARDUINO IDE:</strong><br>Entorno de desarrollo integrado para programar placas Arduino. Simplifica la creación de proyectos de electrónica con una interfaz amigable.<br>
https://www.arduino.cc/en/software

* <strong>WOWKI</strong><br>IoT and Embedded System Simulator para visualizar el correcto funcionamiento de manera interactiva de la placa de arduino con sus componentes.<br>
https://wokwi.com/

* <strong>.INO</strong><br>Extensión de archivo utilizada en el entorno de desarrollo Arduino IDE para identificar programas o proyectos de Arduino. Estos archivos contienen el código fuente y las instrucciones para controlar placas Arduino y otros dispositivos embebidos.<br>
https://www.arduino.cc/reference/en/libraries/du-ino/

<strong>Software Testing</strong><br>
Es el acto de examinar los artefactos y el comportamiento del software bajo prueba mediante validación y verificación. 

* <strong>Lenguaje Gherkins:</strong><br> Es un DSL o Lenguaje Específico de Dominio (Domain-Specific Languaje), es decir, un lenguaje que está creado para resolver un problema. Además de ser interpretado en código, se puede agregar los users stories del programa con sus respectivas partes: Feature, Scenario, Example, Scenario Outline, Given, When, Then y And.
  
<strong>Software Deployment</strong><br>

* <strong>Github Pages:</strong><br> Servicio de Github que nos permitió alojar nuestra Landing page y nos permitirá alojar nuestro web applications.<br>
https://pages.github.com/ <br>
https://github.com/ <br>

* <strong>Firebase:</strong><br> Servicio de Google que nos permite alojar nuestro sitio web con implementación HTTP.<br>
https://www.netlify.com/ 

<strong>Software Documentation</strong>
Es un tipo de texto escrito o ilustración que acompaña al software de computadora o está incrustado en el código fuente. La documentación explica cómo funciona el software o cómo usarlo.

* <strong>OpenAPI Specification vía Swagger:</strong><br> Es una especificación para archivos de interfaz legibles por máquina para describir, producir y visualizar servicios web RESTful. <br>
https://swagger.io/specification/ 
 
### 6.1.1 Source Code Management

A continuación, se presenta la gestión de código fuente o como es conocido por sus siglas en ingles SCM (Source Code Management). Su función principal es realizar un seguimiento de las modificaciones que el equipo realizara a lo largo del desarrollo de sus proyectos en los repositorios de código fuente. Se empleará como un sistema de control de versiones que permite dar seguimiento a los cambios que cada integrante o desarrollador realice en el proyecto. Asimismo, cabe resaltar que para el sistema de control de versiones emplearemos GitHub.

* <strong>URL de la Organización:</strong> https://github.com/MIRAI-Open-Source-SW52-Grupo-3 
  
* <strong>URL del Repositorio del Landing Page:</strong> https://github.com/Open-Source-SW52-Grupo-3/Landing-Page-Import-It 
  
* <strong>URL del Repositorio de Web Services:</strong> Por el momento el equipo no ha creado un repositorio, puesto que no comenzamos con la implementación
  
* <strong>URL del Repositorio de Frontend Web Applications:</strong>  https://github.com/MIRAI-Open-Source-SW52-Grupo-3/Import_It_Web_Application
  
* <strong>URL del Repositorio de las pruebas de aceptación:</strong>  https://github.com/MIRAI-Open-Source-SW52-Grupo-3/Acceptance-Tests 

<strong>GitFlow</strong><br>
Es el modelo alternativo de creación de ramas en Git que en los últimos años se ha vuelto una herramienta indispensable para muchos desarrolladores. Este flujo de trabajo de control de versiones utiliza ramas y fue publicado y popularizado por Vincent Driessen. Su principal función es ayudar en la organización de la versión de un código, permitiendo la creación de nuevos Features y Hotfixes de manera organizada. 
 

Como se mencionó anteriormente, GitFlow trabaja con branches o ramas. A continuación, se muestran las ramas que se emplearan en el flujo de trabajo de nuestro proyecto.

* <strong>Main Branches</strong>
   * <strong>Master:</strong> Esta
es la rama principal, a partir de ella se recorrerán todas las ramas y contendrá la última versión y las anteriores creadas por los desarrolladores. Almacenara el historial de publicación oficial.

  * <strong>Develop:</strong> Esta rama puede ser creada a partir de la master Branch, contara con todos los Features estables. Esto significa que a través de esta rama el equipo podrá integrar las funciones. 

* <strong>Support Branches:</strong>
A diferencia de las ramas principales, estas branches tienen un tiempo de vida limitado, ya que se eliminar al realizar el merge con sus ramas primarias.

  * <strong>Feature:</strong> 
    * Se ramifica de develop. 
    * Debe fusionarse de nuevo en develop <br>

	Se emplean para desarrollar las nuevas funciones que se integraran en una versión siguiente. Cabe resaltar, que esta rama existe mientras este en proceso de desarrollo. Sin embargo, cuando el desarrollador culmine con esa función, se fusionará nuevamente a develop. 

	![GitFLow.](https://raw.githubusercontent.com/NexusNova-IOT/upc-pre-202302-si572-SW71-nexusnova-report/feature/chapter-6/Resources/maps/ImpactMapping-AgenciaDeViajes.png)

  * <strong>Release:</strong>  <br>	
    * Se ramifica de: develop
    * Debe fusionarse de nuevo en: develop/master 
  
	 Son aquellas que admiten la preparación de una nueva versión de producción. A través de esta rama, se permite corregir errores menores que surgieron en la etapa de desarrollo y preparar metadatos para su lanzamiento. Esto último genera que la develop Branch se autoriza para recibir nuevas funciones para la próxima versión, pues se generara cuando se acerque una fecha de publicación determinada. 

 ![Branches.](https://raw.githubusercontent.com/NexusNova-IOT/upc-pre-202302-si572-SW71-nexusnova-report/feature/chapter-6/Resources/maps/ImpactMapping-AgenciaDeViajes.png)
 
o	Hotfix
	Se ramifica de: master
	Debe fusionarse de nuevo en: develop y master
Estas ramas son muy similares a las reléase branches, ya que también están destinadas para una nueva versión de producción, pero con la diferencia que se ramifican de master y no de develop. Son llamadas como ramas de mantenimiento, corrección o hotfix. Su principal función, es reparar rápidamente las publicaciones de producción. Al terminar la corrección, debe fusionarse con master y esta debe etiquetarse con un nuevo número de versión. 


Principales motivos por los que el equipo empleara GitFlow.
•	Este flujo de trabajo es ideal para el equipo, puesto que nuestro proyecto se basa en publicaciones en un determinado sprint.
•	Esta centralizado como subversión (SVN) y descentralizado, que permite que el equipo trabaje individualmente. Pues no todos tienen el mismo horario. Sin embargo, todos deben mantener las actualizaciones en el repositorio central en GitHub.
 
Convenciones para nombrar los Features, reléase y hotfix branches:
Feature Branch: feature/name
Example: 
1.	feature/welcome, 
2.	feature/about, 
3.	feature/myfeature
Antes de mostrar las convenciones para nombrar los reléase and hotfix branches. We have to mostrar cómo es que funciona el Semantic Versioning Specification. 
Este es un sistema de versiones, cuyo uso ha ido aumentando con el transcurso del tiempo por los desarrolladores. Con ello, developers pueden visualizar la extensión de los cambios en el código fuente del proyecto.
Inicialmente, la versión se basa de MAJOR.MINOR.PATCH (X.Y.Z). Asimismo, para comenzar a usar este sistema de versiones debemos declarar una API publica precisa y comprensible. Esta forma debe aumentar numéricamente según lo desarrollado por el equipo de software. 
El proyecto inicia su desarrollo con la versión 0.y.z, luego pasara a ser 1.0.0 cuando se defina la API pública. Siguientemente, se seguirán los criterios mostrados a continuación para incrementar la versión. 
Patch version (Z), debe incrementarse si solo se introducen correcciones de errores compatibles con versiones anteriores.
Minor version (Y), debe incrementarse si el equipo integra una nueva funcionalidad compatible con versiones anteriores en la API pública. Si alguna funcionalidad es obsoleta o si se introducen nuevas funcionalidades en el código privado. 
*Si se incrementa, la version del parche debe volver a 0.
Major version (X), debe incrementarse si se generan cambios deslindados a versiones anteriores en la API pública. 
*Si se incrementa, Patch version y la minor version debe volver a 0.
Existen etiquetas adicionales para los metadatos de compilación. 
Ejemplo:  MAJOR.MINOR. PATCH (X.Y.Z)
1.	1.9.0
2.	1.10.0
3.	2.0.0
4.	1.0.0-alfa
Release Branch:  release-* (* se cambia por la versión semántica).
Ejemplo: release-1.2.0
Hotfix Branch:  hotfix-* (* se cambia por la versión semántica).
Ejemplo: hotfix-1.2.1
Conventional Commits
El commit debe estructurarse de la siguiente manera:
<type>[optional scope]: <description>
[optional body]
[optional footer(s)]
Cabe recalcar que debe estar en “lower case”.
Type: 
feat: Cuando se agrega un nuevo feature.
fix: cuando corriges un error.
build: cuando afectan los componentes de compilación como la herramienta de compilación, las dependencias o la version del proyecto.
chore: modificaciones privadas del código.
docs: commits que afectan solo a la documentación.
refractor: commits que reescriben o reestructura el código, pero no cambia el comportamiento.
perf: commits especiales que mejoran el rendimiento. 
style: commits que no afectan el programa. (espacios en blanco, formato, puntos o comas faltantes).
test: commits que agregan pruebas.
Scope
Proporciona información contextual adicional, si bien es opcional, es bueno colocarlo para que el desarrollador lea un commit más específico. 
<description>
Es una parte obligatoria del formato de los commits, siempre debemos usar imperativo y no escribir en mayúsculas. 
[optional body]
Debe incluirse la motivación para el cambio y contrastarse con el comportamiento anterior. Es opcional y si lo usa debe usar el imperativo y es ideal para mencionar los identificadores de problemas y sus relaciones.
[optional footer(s)]
Cualquier información sobre cambios importantes. Es opcional, puede incluir referencia al problema por su id y en esta sección se incluyen los BREAKING CHANGES: seguido de un espacio o dos satos de línea. 
 Ejemplos:
1.	feat(welcome): add welcome section
2.	build(release): bump version to 1.0.0
3.	style: remove empty line
4.	feat(sign up): add the button to sign up
5.	feat ! : send an-email to the costumer when product is shipped
6.	feat: remove ticket list endpoint
refers to JIRA-1337
BREAKING CHANGES: ticket enpoints no longer supports list all entites.
 

